/// Generated by the Protocol Buffers 3.1.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "http.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Events{}

public extension Events {
    public struct HttpRoot {
        public static let `default` = HttpRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Events.UuidRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    //// Type of peer handling request.
    public enum PeerType:Int32, GeneratedEnum {
        //// Request is made by this process.
        case client = 1

        //// Request is received by this process.
        case server = 2
        public func toString() -> String {
            switch self {
            case .client: return "Client"
            case .server: return "Server"
            }
        }
        public static func fromString(_ str:String) throws -> Events.PeerType {
            switch str {
            case "Client":    return .client
            case "Server":    return .server
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .client: return ".client"
            case .server: return ".server"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:PeerType, rhs:PeerType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    //// HTTP method.
    public enum Method:Int32, GeneratedEnum {
        case `get` = 1
        case post = 2
        case put = 3
        case delete = 4
        case head = 5
        case acl = 6
        case baselineControl = 7
        case bind = 8
        case checkin = 9
        case checkout = 10
        case connect = 11
        case copy = 12
        case debug = 13
        case label = 14
        case link = 15
        case lock = 16
        case merge = 17
        case mkactivity = 18
        case mkcalendar = 19
        case mkcol = 20
        case mkredirectref = 21
        case mkworkspace = 22
        case move = 23
        case options = 24
        case orderpatch = 25
        case patch = 26
        case pri = 27
        case propfind = 28
        case proppatch = 29
        case rebind = 30
        case report = 31
        case search = 32
        case showmethod = 33
        case spacejump = 34
        case textsearch = 35
        case trace = 36
        case track = 37
        case unbind = 38
        case uncheckout = 39
        case unlink = 40
        case unlock = 41
        case update = 42
        case updateredirectref = 43
        case versionControl = 44
        public func toString() -> String {
            switch self {
            case .`get`: return "GET"
            case .post: return "POST"
            case .put: return "PUT"
            case .delete: return "DELETE"
            case .head: return "HEAD"
            case .acl: return "ACL"
            case .baselineControl: return "BASELINE_CONTROL"
            case .bind: return "BIND"
            case .checkin: return "CHECKIN"
            case .checkout: return "CHECKOUT"
            case .connect: return "CONNECT"
            case .copy: return "COPY"
            case .debug: return "DEBUG"
            case .label: return "LABEL"
            case .link: return "LINK"
            case .lock: return "LOCK"
            case .merge: return "MERGE"
            case .mkactivity: return "MKACTIVITY"
            case .mkcalendar: return "MKCALENDAR"
            case .mkcol: return "MKCOL"
            case .mkredirectref: return "MKREDIRECTREF"
            case .mkworkspace: return "MKWORKSPACE"
            case .move: return "MOVE"
            case .options: return "OPTIONS"
            case .orderpatch: return "ORDERPATCH"
            case .patch: return "PATCH"
            case .pri: return "PRI"
            case .propfind: return "PROPFIND"
            case .proppatch: return "PROPPATCH"
            case .rebind: return "REBIND"
            case .report: return "REPORT"
            case .search: return "SEARCH"
            case .showmethod: return "SHOWMETHOD"
            case .spacejump: return "SPACEJUMP"
            case .textsearch: return "TEXTSEARCH"
            case .trace: return "TRACE"
            case .track: return "TRACK"
            case .unbind: return "UNBIND"
            case .uncheckout: return "UNCHECKOUT"
            case .unlink: return "UNLINK"
            case .unlock: return "UNLOCK"
            case .update: return "UPDATE"
            case .updateredirectref: return "UPDATEREDIRECTREF"
            case .versionControl: return "VERSION_CONTROL"
            }
        }
        public static func fromString(_ str:String) throws -> Events.Method {
            switch str {
            case "GET":    return .`get`
            case "POST":    return .post
            case "PUT":    return .put
            case "DELETE":    return .delete
            case "HEAD":    return .head
            case "ACL":    return .acl
            case "BASELINE_CONTROL":    return .baselineControl
            case "BIND":    return .bind
            case "CHECKIN":    return .checkin
            case "CHECKOUT":    return .checkout
            case "CONNECT":    return .connect
            case "COPY":    return .copy
            case "DEBUG":    return .debug
            case "LABEL":    return .label
            case "LINK":    return .link
            case "LOCK":    return .lock
            case "MERGE":    return .merge
            case "MKACTIVITY":    return .mkactivity
            case "MKCALENDAR":    return .mkcalendar
            case "MKCOL":    return .mkcol
            case "MKREDIRECTREF":    return .mkredirectref
            case "MKWORKSPACE":    return .mkworkspace
            case "MOVE":    return .move
            case "OPTIONS":    return .options
            case "ORDERPATCH":    return .orderpatch
            case "PATCH":    return .patch
            case "PRI":    return .pri
            case "PROPFIND":    return .propfind
            case "PROPPATCH":    return .proppatch
            case "REBIND":    return .rebind
            case "REPORT":    return .report
            case "SEARCH":    return .search
            case "SHOWMETHOD":    return .showmethod
            case "SPACEJUMP":    return .spacejump
            case "TEXTSEARCH":    return .textsearch
            case "TRACE":    return .trace
            case "TRACK":    return .track
            case "UNBIND":    return .unbind
            case "UNCHECKOUT":    return .uncheckout
            case "UNLINK":    return .unlink
            case "UNLOCK":    return .unlock
            case "UPDATE":    return .update
            case "UPDATEREDIRECTREF":    return .updateredirectref
            case "VERSION_CONTROL":    return .versionControl
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .`get`: return ".`get`"
            case .post: return ".post"
            case .put: return ".put"
            case .delete: return ".delete"
            case .head: return ".head"
            case .acl: return ".acl"
            case .baselineControl: return ".baselineControl"
            case .bind: return ".bind"
            case .checkin: return ".checkin"
            case .checkout: return ".checkout"
            case .connect: return ".connect"
            case .copy: return ".copy"
            case .debug: return ".debug"
            case .label: return ".label"
            case .link: return ".link"
            case .lock: return ".lock"
            case .merge: return ".merge"
            case .mkactivity: return ".mkactivity"
            case .mkcalendar: return ".mkcalendar"
            case .mkcol: return ".mkcol"
            case .mkredirectref: return ".mkredirectref"
            case .mkworkspace: return ".mkworkspace"
            case .move: return ".move"
            case .options: return ".options"
            case .orderpatch: return ".orderpatch"
            case .patch: return ".patch"
            case .pri: return ".pri"
            case .propfind: return ".propfind"
            case .proppatch: return ".proppatch"
            case .rebind: return ".rebind"
            case .report: return ".report"
            case .search: return ".search"
            case .showmethod: return ".showmethod"
            case .spacejump: return ".spacejump"
            case .textsearch: return ".textsearch"
            case .trace: return ".trace"
            case .track: return ".track"
            case .unbind: return ".unbind"
            case .uncheckout: return ".uncheckout"
            case .unlink: return ".unlink"
            case .unlock: return ".unlock"
            case .update: return ".update"
            case .updateredirectref: return ".updateredirectref"
            case .versionControl: return ".versionControl"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:Method, rhs:Method) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    //// An HttpStartStop event represents the whole lifecycle of an HTTP request.
    final public class HttpStartStop : GeneratedMessage {
        public typealias BuilderType = Events.HttpStartStop.Builder

        public static func == (lhs: Events.HttpStartStop, rhs: Events.HttpStartStop) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStartTimestamp == rhs.hasStartTimestamp) && (!lhs.hasStartTimestamp || lhs.startTimestamp == rhs.startTimestamp)
            fieldCheck = fieldCheck && (lhs.hasStopTimestamp == rhs.hasStopTimestamp) && (!lhs.hasStopTimestamp || lhs.stopTimestamp == rhs.stopTimestamp)
            fieldCheck = fieldCheck && (lhs.hasRequestId == rhs.hasRequestId) && (!lhs.hasRequestId || lhs.requestId == rhs.requestId)
            fieldCheck = fieldCheck && (lhs.hasPeerType == rhs.hasPeerType) && (!lhs.hasPeerType || lhs.peerType == rhs.peerType)
            fieldCheck = fieldCheck && (lhs.hasMethod == rhs.hasMethod) && (!lhs.hasMethod || lhs.method == rhs.method)
            fieldCheck = fieldCheck && (lhs.hasUri == rhs.hasUri) && (!lhs.hasUri || lhs.uri == rhs.uri)
            fieldCheck = fieldCheck && (lhs.hasRemoteAddress == rhs.hasRemoteAddress) && (!lhs.hasRemoteAddress || lhs.remoteAddress == rhs.remoteAddress)
            fieldCheck = fieldCheck && (lhs.hasUserAgent == rhs.hasUserAgent) && (!lhs.hasUserAgent || lhs.userAgent == rhs.userAgent)
            fieldCheck = fieldCheck && (lhs.hasStatusCode == rhs.hasStatusCode) && (!lhs.hasStatusCode || lhs.statusCode == rhs.statusCode)
            fieldCheck = fieldCheck && (lhs.hasContentLength == rhs.hasContentLength) && (!lhs.hasContentLength || lhs.contentLength == rhs.contentLength)
            fieldCheck = fieldCheck && (lhs.hasApplicationId == rhs.hasApplicationId) && (!lhs.hasApplicationId || lhs.applicationId == rhs.applicationId)
            fieldCheck = fieldCheck && (lhs.hasInstanceIndex == rhs.hasInstanceIndex) && (!lhs.hasInstanceIndex || lhs.instanceIndex == rhs.instanceIndex)
            fieldCheck = fieldCheck && (lhs.hasInstanceId == rhs.hasInstanceId) && (!lhs.hasInstanceId || lhs.instanceId == rhs.instanceId)
            fieldCheck = fieldCheck && (lhs.forwarded == rhs.forwarded)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// UNIX timestamp (in nanoseconds) when the request was sent (by a client) or received (by a server).
        public fileprivate(set) var startTimestamp:Int64! = nil
        public fileprivate(set) var hasStartTimestamp:Bool = false

        //// UNIX timestamp (in nanoseconds) when the request was received.
        public fileprivate(set) var stopTimestamp:Int64! = nil
        public fileprivate(set) var hasStopTimestamp:Bool = false

        public fileprivate(set) var requestId:Events.Uuid!
        public fileprivate(set) var hasRequestId:Bool = false
        public fileprivate(set) var peerType:Events.PeerType = Events.PeerType.client
        public fileprivate(set) var hasPeerType:Bool = false
        public fileprivate(set) var method:Events.Method = Events.Method.`get`
        public fileprivate(set) var hasMethod:Bool = false
        //// Destination of the request.
        public fileprivate(set) var uri:String! = nil
        public fileprivate(set) var hasUri:Bool = false

        //// Remote address of the request. (For a server, this should be the origin of the request.)
        public fileprivate(set) var remoteAddress:String! = nil
        public fileprivate(set) var hasRemoteAddress:Bool = false

        //// Contents of the UserAgent header on the request.
        public fileprivate(set) var userAgent:String! = nil
        public fileprivate(set) var hasUserAgent:Bool = false

        //// Status code returned with the response to the request.
        public fileprivate(set) var statusCode:Int32! = nil
        public fileprivate(set) var hasStatusCode:Bool = false

        //// Length of response (bytes).
        public fileprivate(set) var contentLength:Int64! = nil
        public fileprivate(set) var hasContentLength:Bool = false

        public fileprivate(set) var applicationId:Events.Uuid!
        public fileprivate(set) var hasApplicationId:Bool = false
        //// Index of the application instance.
        public fileprivate(set) var instanceIndex:Int32! = nil
        public fileprivate(set) var hasInstanceIndex:Bool = false

        //// ID of the application instance.
        public fileprivate(set) var instanceId:String! = nil
        public fileprivate(set) var hasInstanceId:Bool = false

        //// This contains http forwarded-for [x-forwarded-for] header from the request.
        public fileprivate(set) var forwarded:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasStartTimestamp {
                return false
            }
            if !hasStopTimestamp {
                return false
            }
            if !hasRequestId {
                return false
            }
            if !hasPeerType {
                return false
            }
            if !hasMethod {
                return false
            }
            if !hasUri {
                return false
            }
            if !hasRemoteAddress {
                return false
            }
            if !hasUserAgent {
                return false
            }
            if !hasStatusCode {
                return false
            }
            if !hasContentLength {
                return false
            }
            if !requestId.isInitialized() {
                return false
            }
            if hasApplicationId {
                if !applicationId.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStartTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:startTimestamp)
            }
            if hasStopTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:stopTimestamp)
            }
            if hasRequestId {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:requestId)
            }
            if hasPeerType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:peerType.rawValue)
            }
            if hasMethod {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:method.rawValue)
            }
            if hasUri {
                try codedOutputStream.writeString(fieldNumber: 6, value:uri)
            }
            if hasRemoteAddress {
                try codedOutputStream.writeString(fieldNumber: 7, value:remoteAddress)
            }
            if hasUserAgent {
                try codedOutputStream.writeString(fieldNumber: 8, value:userAgent)
            }
            if hasStatusCode {
                try codedOutputStream.writeInt32(fieldNumber: 9, value:statusCode)
            }
            if hasContentLength {
                try codedOutputStream.writeInt64(fieldNumber: 10, value:contentLength)
            }
            if hasApplicationId {
                try codedOutputStream.writeMessage(fieldNumber: 12, value:applicationId)
            }
            if hasInstanceIndex {
                try codedOutputStream.writeInt32(fieldNumber: 13, value:instanceIndex)
            }
            if hasInstanceId {
                try codedOutputStream.writeString(fieldNumber: 14, value:instanceId)
            }
            if !forwarded.isEmpty {
                for oneValueforwarded in forwarded {
                    try codedOutputStream.writeString(fieldNumber: 15, value:oneValueforwarded)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStartTimestamp {
                serialize_size += startTimestamp.computeInt64Size(fieldNumber: 1)
            }
            if hasStopTimestamp {
                serialize_size += stopTimestamp.computeInt64Size(fieldNumber: 2)
            }
            if hasRequestId {
                if let varSizerequestId = requestId?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizerequestId
                }
            }
            if (hasPeerType) {
                serialize_size += peerType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if (hasMethod) {
                serialize_size += method.rawValue.computeEnumSize(fieldNumber: 5)
            }
            if hasUri {
                serialize_size += uri.computeStringSize(fieldNumber: 6)
            }
            if hasRemoteAddress {
                serialize_size += remoteAddress.computeStringSize(fieldNumber: 7)
            }
            if hasUserAgent {
                serialize_size += userAgent.computeStringSize(fieldNumber: 8)
            }
            if hasStatusCode {
                serialize_size += statusCode.computeInt32Size(fieldNumber: 9)
            }
            if hasContentLength {
                serialize_size += contentLength.computeInt64Size(fieldNumber: 10)
            }
            if hasApplicationId {
                if let varSizeapplicationId = applicationId?.computeMessageSize(fieldNumber: 12) {
                    serialize_size += varSizeapplicationId
                }
            }
            if hasInstanceIndex {
                serialize_size += instanceIndex.computeInt32Size(fieldNumber: 13)
            }
            if hasInstanceId {
                serialize_size += instanceId.computeStringSize(fieldNumber: 14)
            }
            var dataSizeForwarded:Int32 = 0
            for oneValueforwarded in forwarded {
                dataSizeForwarded += oneValueforwarded.computeStringSizeNoTag()
            }
            serialize_size += dataSizeForwarded
            serialize_size += 1 * Int32(forwarded.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Events.HttpStartStop.Builder {
            return Events.HttpStartStop.classBuilder() as! Events.HttpStartStop.Builder
        }
        public func getBuilder() -> Events.HttpStartStop.Builder {
            return classBuilder() as! Events.HttpStartStop.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.HttpStartStop.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.HttpStartStop.Builder()
        }
        public func toBuilder() throws -> Events.HttpStartStop.Builder {
            return try Events.HttpStartStop.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Events.HttpStartStop) throws -> Events.HttpStartStop.Builder {
            return try Events.HttpStartStop.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStartTimestamp {
                jsonMap["startTimestamp"] = "\(startTimestamp)"
            }
            if hasStopTimestamp {
                jsonMap["stopTimestamp"] = "\(stopTimestamp)"
            }
            if hasRequestId {
                jsonMap["requestId"] = try requestId.encode()
            }
            if hasPeerType {
                jsonMap["peerType"] = peerType.toString()
            }
            if hasMethod {
                jsonMap["method"] = method.toString()
            }
            if hasUri {
                jsonMap["uri"] = uri
            }
            if hasRemoteAddress {
                jsonMap["remoteAddress"] = remoteAddress
            }
            if hasUserAgent {
                jsonMap["userAgent"] = userAgent
            }
            if hasStatusCode {
                jsonMap["statusCode"] = Int(statusCode)
            }
            if hasContentLength {
                jsonMap["contentLength"] = "\(contentLength)"
            }
            if hasApplicationId {
                jsonMap["applicationId"] = try applicationId.encode()
            }
            if hasInstanceIndex {
                jsonMap["instanceIndex"] = Int(instanceIndex)
            }
            if hasInstanceId {
                jsonMap["instanceId"] = instanceId
            }
            if !forwarded.isEmpty {
                var jsonArrayForwarded:Array<String> = []
                for oneValueForwarded in forwarded {
                    jsonArrayForwarded.append(oneValueForwarded)
                }
                jsonMap["forwarded"] = jsonArrayForwarded
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Events.HttpStartStop {
            return try Events.HttpStartStop.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Events.HttpStartStop {
            return try Events.HttpStartStop.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStartTimestamp {
                output += "\(indent) startTimestamp: \(startTimestamp) \n"
            }
            if hasStopTimestamp {
                output += "\(indent) stopTimestamp: \(stopTimestamp) \n"
            }
            if hasRequestId {
                output += "\(indent) requestId {\n"
                if let outDescRequestId = requestId {
                    output += try outDescRequestId.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasPeerType) {
                output += "\(indent) peerType: \(peerType.description)\n"
            }
            if (hasMethod) {
                output += "\(indent) method: \(method.description)\n"
            }
            if hasUri {
                output += "\(indent) uri: \(uri) \n"
            }
            if hasRemoteAddress {
                output += "\(indent) remoteAddress: \(remoteAddress) \n"
            }
            if hasUserAgent {
                output += "\(indent) userAgent: \(userAgent) \n"
            }
            if hasStatusCode {
                output += "\(indent) statusCode: \(statusCode) \n"
            }
            if hasContentLength {
                output += "\(indent) contentLength: \(contentLength) \n"
            }
            if hasApplicationId {
                output += "\(indent) applicationId {\n"
                if let outDescApplicationId = applicationId {
                    output += try outDescApplicationId.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInstanceIndex {
                output += "\(indent) instanceIndex: \(instanceIndex) \n"
            }
            if hasInstanceId {
                output += "\(indent) instanceId: \(instanceId) \n"
            }
            var forwardedElementIndex:Int = 0
            for oneValueForwarded in forwarded  {
                output += "\(indent) forwarded[\(forwardedElementIndex)]: \(oneValueForwarded)\n"
                forwardedElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStartTimestamp {
                    hashCode = (hashCode &* 31) &+ startTimestamp.hashValue
                }
                if hasStopTimestamp {
                    hashCode = (hashCode &* 31) &+ stopTimestamp.hashValue
                }
                if hasRequestId {
                    if let hashValuerequestId = requestId?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuerequestId
                    }
                }
                if hasPeerType {
                     hashCode = (hashCode &* 31) &+ peerType.hashValue
                }
                if hasMethod {
                     hashCode = (hashCode &* 31) &+ method.hashValue
                }
                if hasUri {
                    hashCode = (hashCode &* 31) &+ uri.hashValue
                }
                if hasRemoteAddress {
                    hashCode = (hashCode &* 31) &+ remoteAddress.hashValue
                }
                if hasUserAgent {
                    hashCode = (hashCode &* 31) &+ userAgent.hashValue
                }
                if hasStatusCode {
                    hashCode = (hashCode &* 31) &+ statusCode.hashValue
                }
                if hasContentLength {
                    hashCode = (hashCode &* 31) &+ contentLength.hashValue
                }
                if hasApplicationId {
                    if let hashValueapplicationId = applicationId?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueapplicationId
                    }
                }
                if hasInstanceIndex {
                    hashCode = (hashCode &* 31) &+ instanceIndex.hashValue
                }
                if hasInstanceId {
                    hashCode = (hashCode &* 31) &+ instanceId.hashValue
                }
                for oneValueForwarded in forwarded {
                    hashCode = (hashCode &* 31) &+ oneValueForwarded.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Events.HttpStartStop"
        }
        override public func className() -> String {
            return "Events.HttpStartStop"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Events.HttpStartStop = Events.HttpStartStop()
            public func getMessage() -> Events.HttpStartStop {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// UNIX timestamp (in nanoseconds) when the request was sent (by a client) or received (by a server).
            public var startTimestamp:Int64 {
                get {
                    return builderResult.startTimestamp
                }
                set (value) {
                    builderResult.hasStartTimestamp = true
                    builderResult.startTimestamp = value
                }
            }
            public var hasStartTimestamp:Bool {
                get {
                    return builderResult.hasStartTimestamp
                }
            }
            @discardableResult
            public func setStartTimestamp(_ value:Int64) -> Events.HttpStartStop.Builder {
                self.startTimestamp = value
                return self
            }
            @discardableResult
            public func clearStartTimestamp() -> Events.HttpStartStop.Builder{
                builderResult.hasStartTimestamp = false
                builderResult.startTimestamp = nil
                return self
            }
            //// UNIX timestamp (in nanoseconds) when the request was received.
            public var stopTimestamp:Int64 {
                get {
                    return builderResult.stopTimestamp
                }
                set (value) {
                    builderResult.hasStopTimestamp = true
                    builderResult.stopTimestamp = value
                }
            }
            public var hasStopTimestamp:Bool {
                get {
                    return builderResult.hasStopTimestamp
                }
            }
            @discardableResult
            public func setStopTimestamp(_ value:Int64) -> Events.HttpStartStop.Builder {
                self.stopTimestamp = value
                return self
            }
            @discardableResult
            public func clearStopTimestamp() -> Events.HttpStartStop.Builder{
                builderResult.hasStopTimestamp = false
                builderResult.stopTimestamp = nil
                return self
            }
            //// ID for tracking lifecycle of request.
            public var requestId:Events.Uuid! {
                get {
                    if requestIdBuilder_ != nil {
                        builderResult.requestId = requestIdBuilder_.getMessage()
                    }
                    return builderResult.requestId
                }
                set (value) {
                    builderResult.hasRequestId = true
                    builderResult.requestId = value
                }
            }
            public var hasRequestId:Bool {
                get {
                    return builderResult.hasRequestId
                }
            }
            fileprivate var requestIdBuilder_:Events.Uuid.Builder! {
                didSet {
                    builderResult.hasRequestId = true
                }
            }
            public func getRequestIdBuilder() -> Events.Uuid.Builder {
                if requestIdBuilder_ == nil {
                    requestIdBuilder_ = Events.Uuid.Builder()
                    builderResult.requestId = requestIdBuilder_.getMessage()
                    if requestId != nil {
                        try! requestIdBuilder_.mergeFrom(other: requestId)
                    }
                }
                return requestIdBuilder_
            }
            @discardableResult
            public func setRequestId(_ value:Events.Uuid!) -> Events.HttpStartStop.Builder {
                self.requestId = value
                return self
            }
            @discardableResult
            public func mergeRequestId(value:Events.Uuid) throws -> Events.HttpStartStop.Builder {
                if builderResult.hasRequestId {
                    builderResult.requestId = try Events.Uuid.builderWithPrototype(prototype:builderResult.requestId).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.requestId = value
                }
                builderResult.hasRequestId = true
                return self
            }
            @discardableResult
            public func clearRequestId() -> Events.HttpStartStop.Builder {
                requestIdBuilder_ = nil
                builderResult.hasRequestId = false
                builderResult.requestId = nil
                return self
            }
            //// Role of the emitting process in the request cycle.
                public var peerType:Events.PeerType {
                    get {
                        return builderResult.peerType
                    }
                    set (value) {
                        builderResult.hasPeerType = true
                        builderResult.peerType = value
                    }
                }
                public var hasPeerType:Bool{
                    get {
                        return builderResult.hasPeerType
                    }
                }
            @discardableResult
                public func setPeerType(_ value:Events.PeerType) -> Events.HttpStartStop.Builder {
                  self.peerType = value
                  return self
                }
            @discardableResult
                public func clearPeerType() -> Events.HttpStartStop.Builder {
                   builderResult.hasPeerType = false
                   builderResult.peerType = .client
                   return self
                }
            //// Method of the request.
                public var method:Events.Method {
                    get {
                        return builderResult.method
                    }
                    set (value) {
                        builderResult.hasMethod = true
                        builderResult.method = value
                    }
                }
                public var hasMethod:Bool{
                    get {
                        return builderResult.hasMethod
                    }
                }
            @discardableResult
                public func setMethod(_ value:Events.Method) -> Events.HttpStartStop.Builder {
                  self.method = value
                  return self
                }
            @discardableResult
                public func clearMethod() -> Events.HttpStartStop.Builder {
                   builderResult.hasMethod = false
                   builderResult.method = .`get`
                   return self
                }
            //// Destination of the request.
            public var uri:String {
                get {
                    return builderResult.uri
                }
                set (value) {
                    builderResult.hasUri = true
                    builderResult.uri = value
                }
            }
            public var hasUri:Bool {
                get {
                    return builderResult.hasUri
                }
            }
            @discardableResult
            public func setUri(_ value:String) -> Events.HttpStartStop.Builder {
                self.uri = value
                return self
            }
            @discardableResult
            public func clearUri() -> Events.HttpStartStop.Builder{
                builderResult.hasUri = false
                builderResult.uri = nil
                return self
            }
            //// Remote address of the request. (For a server, this should be the origin of the request.)
            public var remoteAddress:String {
                get {
                    return builderResult.remoteAddress
                }
                set (value) {
                    builderResult.hasRemoteAddress = true
                    builderResult.remoteAddress = value
                }
            }
            public var hasRemoteAddress:Bool {
                get {
                    return builderResult.hasRemoteAddress
                }
            }
            @discardableResult
            public func setRemoteAddress(_ value:String) -> Events.HttpStartStop.Builder {
                self.remoteAddress = value
                return self
            }
            @discardableResult
            public func clearRemoteAddress() -> Events.HttpStartStop.Builder{
                builderResult.hasRemoteAddress = false
                builderResult.remoteAddress = nil
                return self
            }
            //// Contents of the UserAgent header on the request.
            public var userAgent:String {
                get {
                    return builderResult.userAgent
                }
                set (value) {
                    builderResult.hasUserAgent = true
                    builderResult.userAgent = value
                }
            }
            public var hasUserAgent:Bool {
                get {
                    return builderResult.hasUserAgent
                }
            }
            @discardableResult
            public func setUserAgent(_ value:String) -> Events.HttpStartStop.Builder {
                self.userAgent = value
                return self
            }
            @discardableResult
            public func clearUserAgent() -> Events.HttpStartStop.Builder{
                builderResult.hasUserAgent = false
                builderResult.userAgent = nil
                return self
            }
            //// Status code returned with the response to the request.
            public var statusCode:Int32 {
                get {
                    return builderResult.statusCode
                }
                set (value) {
                    builderResult.hasStatusCode = true
                    builderResult.statusCode = value
                }
            }
            public var hasStatusCode:Bool {
                get {
                    return builderResult.hasStatusCode
                }
            }
            @discardableResult
            public func setStatusCode(_ value:Int32) -> Events.HttpStartStop.Builder {
                self.statusCode = value
                return self
            }
            @discardableResult
            public func clearStatusCode() -> Events.HttpStartStop.Builder{
                builderResult.hasStatusCode = false
                builderResult.statusCode = nil
                return self
            }
            //// Length of response (bytes).
            public var contentLength:Int64 {
                get {
                    return builderResult.contentLength
                }
                set (value) {
                    builderResult.hasContentLength = true
                    builderResult.contentLength = value
                }
            }
            public var hasContentLength:Bool {
                get {
                    return builderResult.hasContentLength
                }
            }
            @discardableResult
            public func setContentLength(_ value:Int64) -> Events.HttpStartStop.Builder {
                self.contentLength = value
                return self
            }
            @discardableResult
            public func clearContentLength() -> Events.HttpStartStop.Builder{
                builderResult.hasContentLength = false
                builderResult.contentLength = nil
                return self
            }
            //// If this request was made in relation to an appliciation, this field should track that application's ID.
            public var applicationId:Events.Uuid! {
                get {
                    if applicationIdBuilder_ != nil {
                        builderResult.applicationId = applicationIdBuilder_.getMessage()
                    }
                    return builderResult.applicationId
                }
                set (value) {
                    builderResult.hasApplicationId = true
                    builderResult.applicationId = value
                }
            }
            public var hasApplicationId:Bool {
                get {
                    return builderResult.hasApplicationId
                }
            }
            fileprivate var applicationIdBuilder_:Events.Uuid.Builder! {
                didSet {
                    builderResult.hasApplicationId = true
                }
            }
            public func getApplicationIdBuilder() -> Events.Uuid.Builder {
                if applicationIdBuilder_ == nil {
                    applicationIdBuilder_ = Events.Uuid.Builder()
                    builderResult.applicationId = applicationIdBuilder_.getMessage()
                    if applicationId != nil {
                        try! applicationIdBuilder_.mergeFrom(other: applicationId)
                    }
                }
                return applicationIdBuilder_
            }
            @discardableResult
            public func setApplicationId(_ value:Events.Uuid!) -> Events.HttpStartStop.Builder {
                self.applicationId = value
                return self
            }
            @discardableResult
            public func mergeApplicationId(value:Events.Uuid) throws -> Events.HttpStartStop.Builder {
                if builderResult.hasApplicationId {
                    builderResult.applicationId = try Events.Uuid.builderWithPrototype(prototype:builderResult.applicationId).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.applicationId = value
                }
                builderResult.hasApplicationId = true
                return self
            }
            @discardableResult
            public func clearApplicationId() -> Events.HttpStartStop.Builder {
                applicationIdBuilder_ = nil
                builderResult.hasApplicationId = false
                builderResult.applicationId = nil
                return self
            }
            //// Index of the application instance.
            public var instanceIndex:Int32 {
                get {
                    return builderResult.instanceIndex
                }
                set (value) {
                    builderResult.hasInstanceIndex = true
                    builderResult.instanceIndex = value
                }
            }
            public var hasInstanceIndex:Bool {
                get {
                    return builderResult.hasInstanceIndex
                }
            }
            @discardableResult
            public func setInstanceIndex(_ value:Int32) -> Events.HttpStartStop.Builder {
                self.instanceIndex = value
                return self
            }
            @discardableResult
            public func clearInstanceIndex() -> Events.HttpStartStop.Builder{
                builderResult.hasInstanceIndex = false
                builderResult.instanceIndex = nil
                return self
            }
            //// ID of the application instance.
            public var instanceId:String {
                get {
                    return builderResult.instanceId
                }
                set (value) {
                    builderResult.hasInstanceId = true
                    builderResult.instanceId = value
                }
            }
            public var hasInstanceId:Bool {
                get {
                    return builderResult.hasInstanceId
                }
            }
            @discardableResult
            public func setInstanceId(_ value:String) -> Events.HttpStartStop.Builder {
                self.instanceId = value
                return self
            }
            @discardableResult
            public func clearInstanceId() -> Events.HttpStartStop.Builder{
                builderResult.hasInstanceId = false
                builderResult.instanceId = nil
                return self
            }
            //// This contains http forwarded-for [x-forwarded-for] header from the request.
            public var forwarded:Array<String> {
                get {
                    return builderResult.forwarded
                }
                set (array) {
                    builderResult.forwarded = array
                }
            }
            @discardableResult
            public func setForwarded(_ value:Array<String>) -> Events.HttpStartStop.Builder {
                self.forwarded = value
                return self
            }
            @discardableResult
            public func clearForwarded() -> Events.HttpStartStop.Builder {
                builderResult.forwarded.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Events.HttpStartStop.Builder {
                builderResult = Events.HttpStartStop()
                return self
            }
            override public func clone() throws -> Events.HttpStartStop.Builder {
                return try Events.HttpStartStop.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Events.HttpStartStop {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Events.HttpStartStop {
                let returnMe:Events.HttpStartStop = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Events.HttpStartStop) throws -> Events.HttpStartStop.Builder {
                if other == Events.HttpStartStop() {
                    return self
                }
                if other.hasStartTimestamp {
                    startTimestamp = other.startTimestamp
                }
                if other.hasStopTimestamp {
                    stopTimestamp = other.stopTimestamp
                }
                if (other.hasRequestId) {
                    try mergeRequestId(value: other.requestId)
                }
                if other.hasPeerType {
                    peerType = other.peerType
                }
                if other.hasMethod {
                    method = other.method
                }
                if other.hasUri {
                    uri = other.uri
                }
                if other.hasRemoteAddress {
                    remoteAddress = other.remoteAddress
                }
                if other.hasUserAgent {
                    userAgent = other.userAgent
                }
                if other.hasStatusCode {
                    statusCode = other.statusCode
                }
                if other.hasContentLength {
                    contentLength = other.contentLength
                }
                if (other.hasApplicationId) {
                    try mergeApplicationId(value: other.applicationId)
                }
                if other.hasInstanceIndex {
                    instanceIndex = other.instanceIndex
                }
                if other.hasInstanceId {
                    instanceId = other.instanceId
                }
                if !other.forwarded.isEmpty {
                    builderResult.forwarded += other.forwarded
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Events.HttpStartStop.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.HttpStartStop.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        startTimestamp = try codedInputStream.readInt64()

                    case 16:
                        stopTimestamp = try codedInputStream.readInt64()

                    case 26:
                        let subBuilder:Events.Uuid.Builder = Events.Uuid.Builder()
                        if hasRequestId {
                            try subBuilder.mergeFrom(other: requestId)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        requestId = subBuilder.buildPartial()

                    case 32:
                        let valueIntpeerType = try codedInputStream.readEnum()
                        if let enumspeerType = Events.PeerType(rawValue:valueIntpeerType){
                            peerType = enumspeerType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntpeerType))
                        }

                    case 40:
                        let valueIntmethod = try codedInputStream.readEnum()
                        if let enumsmethod = Events.Method(rawValue:valueIntmethod){
                            method = enumsmethod
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntmethod))
                        }

                    case 50:
                        uri = try codedInputStream.readString()

                    case 58:
                        remoteAddress = try codedInputStream.readString()

                    case 66:
                        userAgent = try codedInputStream.readString()

                    case 72:
                        statusCode = try codedInputStream.readInt32()

                    case 80:
                        contentLength = try codedInputStream.readInt64()

                    case 98:
                        let subBuilder:Events.Uuid.Builder = Events.Uuid.Builder()
                        if hasApplicationId {
                            try subBuilder.mergeFrom(other: applicationId)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        applicationId = subBuilder.buildPartial()

                    case 104:
                        instanceIndex = try codedInputStream.readInt32()

                    case 114:
                        instanceId = try codedInputStream.readString()

                    case 122:
                        forwarded += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Events.HttpStartStop.Builder {
                let resultDecodedBuilder = Events.HttpStartStop.Builder()
                if let jsonValueStartTimestamp = jsonMap["startTimestamp"] as? String {
                    resultDecodedBuilder.startTimestamp = Int64(jsonValueStartTimestamp)!
                } else if let jsonValueStartTimestamp = jsonMap["startTimestamp"] as? Int {
                    resultDecodedBuilder.startTimestamp = Int64(jsonValueStartTimestamp)
                }
                if let jsonValueStopTimestamp = jsonMap["stopTimestamp"] as? String {
                    resultDecodedBuilder.stopTimestamp = Int64(jsonValueStopTimestamp)!
                } else if let jsonValueStopTimestamp = jsonMap["stopTimestamp"] as? Int {
                    resultDecodedBuilder.stopTimestamp = Int64(jsonValueStopTimestamp)
                }
                if let jsonValueRequestId = jsonMap["requestId"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.requestId = try Events.Uuid.Builder.decodeToBuilder(jsonMap:jsonValueRequestId).build()

                }
                if let jsonValuePeerType = jsonMap["peerType"] as? String {
                    resultDecodedBuilder.peerType = try Events.PeerType.fromString(jsonValuePeerType)
                }
                if let jsonValueMethod = jsonMap["method"] as? String {
                    resultDecodedBuilder.method = try Events.Method.fromString(jsonValueMethod)
                }
                if let jsonValueUri = jsonMap["uri"] as? String {
                    resultDecodedBuilder.uri = jsonValueUri
                }
                if let jsonValueRemoteAddress = jsonMap["remoteAddress"] as? String {
                    resultDecodedBuilder.remoteAddress = jsonValueRemoteAddress
                }
                if let jsonValueUserAgent = jsonMap["userAgent"] as? String {
                    resultDecodedBuilder.userAgent = jsonValueUserAgent
                }
                if let jsonValueStatusCode = jsonMap["statusCode"] as? Int {
                    resultDecodedBuilder.statusCode = Int32(jsonValueStatusCode)
                } else if let jsonValueStatusCode = jsonMap["statusCode"] as? String {
                    resultDecodedBuilder.statusCode = Int32(jsonValueStatusCode)!
                }
                if let jsonValueContentLength = jsonMap["contentLength"] as? String {
                    resultDecodedBuilder.contentLength = Int64(jsonValueContentLength)!
                } else if let jsonValueContentLength = jsonMap["contentLength"] as? Int {
                    resultDecodedBuilder.contentLength = Int64(jsonValueContentLength)
                }
                if let jsonValueApplicationId = jsonMap["applicationId"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.applicationId = try Events.Uuid.Builder.decodeToBuilder(jsonMap:jsonValueApplicationId).build()

                }
                if let jsonValueInstanceIndex = jsonMap["instanceIndex"] as? Int {
                    resultDecodedBuilder.instanceIndex = Int32(jsonValueInstanceIndex)
                } else if let jsonValueInstanceIndex = jsonMap["instanceIndex"] as? String {
                    resultDecodedBuilder.instanceIndex = Int32(jsonValueInstanceIndex)!
                }
                if let jsonValueInstanceId = jsonMap["instanceId"] as? String {
                    resultDecodedBuilder.instanceId = jsonValueInstanceId
                }
                if let jsonValueForwarded = jsonMap["forwarded"] as? Array<String> {
                    var jsonArrayForwarded:Array<String> = []
                    for oneValueForwarded in jsonValueForwarded {
                        jsonArrayForwarded.append(oneValueForwarded)
                    }
                    resultDecodedBuilder.forwarded = jsonArrayForwarded
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Events.HttpStartStop.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Events.HttpStartStop.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Events.HttpStartStop: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Events.HttpStartStop> {
        var mergedArray = Array<Events.HttpStartStop>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Events.HttpStartStop? {
        return try Events.HttpStartStop.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(data: data, extensionRegistry:Events.HttpRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.HttpStartStop {
        return try Events.HttpStartStop.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "startTimestamp": return self.startTimestamp
        case "stopTimestamp": return self.stopTimestamp
        case "requestId": return self.requestId
        case "peerType": return self.peerType
        case "method": return self.method
        case "uri": return self.uri
        case "remoteAddress": return self.remoteAddress
        case "userAgent": return self.userAgent
        case "statusCode": return self.statusCode
        case "contentLength": return self.contentLength
        case "applicationId": return self.applicationId
        case "instanceIndex": return self.instanceIndex
        case "instanceId": return self.instanceId
        case "forwarded": return self.forwarded
        default: return nil
        }
    }
}
extension Events.HttpStartStop.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Events.HttpStartStop
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "startTimestamp": return self.startTimestamp
            case "stopTimestamp": return self.stopTimestamp
            case "requestId": return self.requestId
            case "peerType": return self.peerType
            case "method": return self.method
            case "uri": return self.uri
            case "remoteAddress": return self.remoteAddress
            case "userAgent": return self.userAgent
            case "statusCode": return self.statusCode
            case "contentLength": return self.contentLength
            case "applicationId": return self.applicationId
            case "instanceIndex": return self.instanceIndex
            case "instanceId": return self.instanceId
            case "forwarded": return self.forwarded
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "startTimestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.startTimestamp = newSubscriptValue
            case "stopTimestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.stopTimestamp = newSubscriptValue
            case "requestId":
                guard let newSubscriptValue = newSubscriptValue as? Events.Uuid else {
                    return
                }
                self.requestId = newSubscriptValue
            case "peerType":
                guard let newSubscriptValue = newSubscriptValue as? Events.PeerType else {
                    return
                }
                self.peerType = newSubscriptValue
            case "method":
                guard let newSubscriptValue = newSubscriptValue as? Events.Method else {
                    return
                }
                self.method = newSubscriptValue
            case "uri":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uri = newSubscriptValue
            case "remoteAddress":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.remoteAddress = newSubscriptValue
            case "userAgent":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userAgent = newSubscriptValue
            case "statusCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.statusCode = newSubscriptValue
            case "contentLength":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.contentLength = newSubscriptValue
            case "applicationId":
                guard let newSubscriptValue = newSubscriptValue as? Events.Uuid else {
                    return
                }
                self.applicationId = newSubscriptValue
            case "instanceIndex":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.instanceIndex = newSubscriptValue
            case "instanceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.instanceId = newSubscriptValue
            case "forwarded":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.forwarded = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
