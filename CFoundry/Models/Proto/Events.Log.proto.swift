/// Generated by the Protocol Buffers 3.1.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "log.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Events{}

public extension Events {
    public struct LogRoot {
        public static let `default` = LogRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    //// A LogMessage contains a "log line" and associated metadata.
    final public class LogMessage : GeneratedMessage {
        public typealias BuilderType = Events.LogMessage.Builder

        public static func == (lhs: Events.LogMessage, rhs: Events.LogMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
            fieldCheck = fieldCheck && (lhs.hasMessageType == rhs.hasMessageType) && (!lhs.hasMessageType || lhs.messageType == rhs.messageType)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasAppId == rhs.hasAppId) && (!lhs.hasAppId || lhs.appId == rhs.appId)
            fieldCheck = fieldCheck && (lhs.hasSourceType == rhs.hasSourceType) && (!lhs.hasSourceType || lhs.sourceType == rhs.sourceType)
            fieldCheck = fieldCheck && (lhs.hasSourceInstance == rhs.hasSourceInstance) && (!lhs.hasSourceInstance || lhs.sourceInstance == rhs.sourceInstance)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            //// MessageType stores the destination of the message (corresponding to STDOUT or STDERR).
            public enum MessageType:Int32, GeneratedEnum {
                case out = 1
                case err = 2
                public func toString() -> String {
                    switch self {
                    case .out: return "OUT"
                    case .err: return "ERR"
                    }
                }
                public static func fromString(_ str:String) throws -> Events.LogMessage.MessageType {
                    switch str {
                    case "OUT":    return .out
                    case "ERR":    return .err
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .out: return ".out"
                    case .err: return ".err"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:MessageType, rhs:MessageType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        //// Bytes of the log message. (Note that it is not required to be a single line.)
        public fileprivate(set) var message:Data! = nil
        public fileprivate(set) var hasMessage:Bool = false

        public fileprivate(set) var messageType:Events.LogMessage.MessageType = Events.LogMessage.MessageType.out
        public fileprivate(set) var hasMessageType:Bool = false
        //// UNIX timestamp (in nanoseconds) when the log was written.
        public fileprivate(set) var timestamp:Int64! = nil
        public fileprivate(set) var hasTimestamp:Bool = false

        //// Application that emitted the message (or to which the application is related).
        public fileprivate(set) var appId:String! = nil
        public fileprivate(set) var hasAppId:Bool = false

        //// Source of the message. For Cloud Foundry, this can be "APP", "RTR", "DEA", "STG", etc.
        public fileprivate(set) var sourceType:String! = nil
        public fileprivate(set) var hasSourceType:Bool = false

        //// Instance that emitted the message.
        public fileprivate(set) var sourceInstance:String! = nil
        public fileprivate(set) var hasSourceInstance:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasMessage {
                return false
            }
            if !hasMessageType {
                return false
            }
            if !hasTimestamp {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMessage {
                try codedOutputStream.writeData(fieldNumber: 1, value:message)
            }
            if hasMessageType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:messageType.rawValue)
            }
            if hasTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:timestamp)
            }
            if hasAppId {
                try codedOutputStream.writeString(fieldNumber: 4, value:appId)
            }
            if hasSourceType {
                try codedOutputStream.writeString(fieldNumber: 5, value:sourceType)
            }
            if hasSourceInstance {
                try codedOutputStream.writeString(fieldNumber: 6, value:sourceInstance)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMessage {
                serialize_size += message.computeDataSize(fieldNumber: 1)
            }
            if (hasMessageType) {
                serialize_size += messageType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasTimestamp {
                serialize_size += timestamp.computeInt64Size(fieldNumber: 3)
            }
            if hasAppId {
                serialize_size += appId.computeStringSize(fieldNumber: 4)
            }
            if hasSourceType {
                serialize_size += sourceType.computeStringSize(fieldNumber: 5)
            }
            if hasSourceInstance {
                serialize_size += sourceInstance.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Events.LogMessage.Builder {
            return Events.LogMessage.classBuilder() as! Events.LogMessage.Builder
        }
        public func getBuilder() -> Events.LogMessage.Builder {
            return classBuilder() as! Events.LogMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.LogMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.LogMessage.Builder()
        }
        public func toBuilder() throws -> Events.LogMessage.Builder {
            return try Events.LogMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Events.LogMessage) throws -> Events.LogMessage.Builder {
            return try Events.LogMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMessage {
                jsonMap["message"] = message.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasMessageType {
                jsonMap["messageType"] = messageType.toString()
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            if hasAppId {
                jsonMap["appId"] = appId
            }
            if hasSourceType {
                jsonMap["sourceType"] = sourceType
            }
            if hasSourceInstance {
                jsonMap["sourceInstance"] = sourceInstance
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Events.LogMessage {
            return try Events.LogMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Events.LogMessage {
            return try Events.LogMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMessage {
                output += "\(indent) message: \(message) \n"
            }
            if (hasMessageType) {
                output += "\(indent) messageType: \(messageType.description)\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if hasAppId {
                output += "\(indent) appId: \(appId) \n"
            }
            if hasSourceType {
                output += "\(indent) sourceType: \(sourceType) \n"
            }
            if hasSourceInstance {
                output += "\(indent) sourceInstance: \(sourceInstance) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMessage {
                    hashCode = (hashCode &* 31) &+ message.hashValue
                }
                if hasMessageType {
                     hashCode = (hashCode &* 31) &+ messageType.hashValue
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasAppId {
                    hashCode = (hashCode &* 31) &+ appId.hashValue
                }
                if hasSourceType {
                    hashCode = (hashCode &* 31) &+ sourceType.hashValue
                }
                if hasSourceInstance {
                    hashCode = (hashCode &* 31) &+ sourceInstance.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Events.LogMessage"
        }
        override public func className() -> String {
            return "Events.LogMessage"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Events.LogMessage = Events.LogMessage()
            public func getMessage() -> Events.LogMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Bytes of the log message. (Note that it is not required to be a single line.)
            public var message:Data {
                get {
                    return builderResult.message
                }
                set (value) {
                    builderResult.hasMessage = true
                    builderResult.message = value
                }
            }
            public var hasMessage:Bool {
                get {
                    return builderResult.hasMessage
                }
            }
            @discardableResult
            public func setMessage(_ value:Data) -> Events.LogMessage.Builder {
                self.message = value
                return self
            }
            @discardableResult
            public func clearMessage() -> Events.LogMessage.Builder{
                builderResult.hasMessage = false
                builderResult.message = nil
                return self
            }
            //// Type of the message (OUT or ERR).
                public var messageType:Events.LogMessage.MessageType {
                    get {
                        return builderResult.messageType
                    }
                    set (value) {
                        builderResult.hasMessageType = true
                        builderResult.messageType = value
                    }
                }
                public var hasMessageType:Bool{
                    get {
                        return builderResult.hasMessageType
                    }
                }
            @discardableResult
                public func setMessageType(_ value:Events.LogMessage.MessageType) -> Events.LogMessage.Builder {
                  self.messageType = value
                  return self
                }
            @discardableResult
                public func clearMessageType() -> Events.LogMessage.Builder {
                   builderResult.hasMessageType = false
                   builderResult.messageType = .out
                   return self
                }
            //// UNIX timestamp (in nanoseconds) when the log was written.
            public var timestamp:Int64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:Int64) -> Events.LogMessage.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> Events.LogMessage.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = nil
                return self
            }
            //// Application that emitted the message (or to which the application is related).
            public var appId:String {
                get {
                    return builderResult.appId
                }
                set (value) {
                    builderResult.hasAppId = true
                    builderResult.appId = value
                }
            }
            public var hasAppId:Bool {
                get {
                    return builderResult.hasAppId
                }
            }
            @discardableResult
            public func setAppId(_ value:String) -> Events.LogMessage.Builder {
                self.appId = value
                return self
            }
            @discardableResult
            public func clearAppId() -> Events.LogMessage.Builder{
                builderResult.hasAppId = false
                builderResult.appId = nil
                return self
            }
            //// Source of the message. For Cloud Foundry, this can be "APP", "RTR", "DEA", "STG", etc.
            public var sourceType:String {
                get {
                    return builderResult.sourceType
                }
                set (value) {
                    builderResult.hasSourceType = true
                    builderResult.sourceType = value
                }
            }
            public var hasSourceType:Bool {
                get {
                    return builderResult.hasSourceType
                }
            }
            @discardableResult
            public func setSourceType(_ value:String) -> Events.LogMessage.Builder {
                self.sourceType = value
                return self
            }
            @discardableResult
            public func clearSourceType() -> Events.LogMessage.Builder{
                builderResult.hasSourceType = false
                builderResult.sourceType = nil
                return self
            }
            //// Instance that emitted the message.
            public var sourceInstance:String {
                get {
                    return builderResult.sourceInstance
                }
                set (value) {
                    builderResult.hasSourceInstance = true
                    builderResult.sourceInstance = value
                }
            }
            public var hasSourceInstance:Bool {
                get {
                    return builderResult.hasSourceInstance
                }
            }
            @discardableResult
            public func setSourceInstance(_ value:String) -> Events.LogMessage.Builder {
                self.sourceInstance = value
                return self
            }
            @discardableResult
            public func clearSourceInstance() -> Events.LogMessage.Builder{
                builderResult.hasSourceInstance = false
                builderResult.sourceInstance = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Events.LogMessage.Builder {
                builderResult = Events.LogMessage()
                return self
            }
            override public func clone() throws -> Events.LogMessage.Builder {
                return try Events.LogMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Events.LogMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Events.LogMessage {
                let returnMe:Events.LogMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Events.LogMessage) throws -> Events.LogMessage.Builder {
                if other == Events.LogMessage() {
                    return self
                }
                if other.hasMessage {
                    message = other.message
                }
                if other.hasMessageType {
                    messageType = other.messageType
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasAppId {
                    appId = other.appId
                }
                if other.hasSourceType {
                    sourceType = other.sourceType
                }
                if other.hasSourceInstance {
                    sourceInstance = other.sourceInstance
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Events.LogMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.LogMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        message = try codedInputStream.readData()

                    case 16:
                        let valueIntmessageType = try codedInputStream.readEnum()
                        if let enumsmessageType = Events.LogMessage.MessageType(rawValue:valueIntmessageType){
                            messageType = enumsmessageType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntmessageType))
                        }

                    case 24:
                        timestamp = try codedInputStream.readInt64()

                    case 34:
                        appId = try codedInputStream.readString()

                    case 42:
                        sourceType = try codedInputStream.readString()

                    case 50:
                        sourceInstance = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Events.LogMessage.Builder {
                let resultDecodedBuilder = Events.LogMessage.Builder()
                if let jsonValueMessage = jsonMap["message"] as? String {
                    resultDecodedBuilder.message = Data(base64Encoded:jsonValueMessage, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueMessageType = jsonMap["messageType"] as? String {
                    resultDecodedBuilder.messageType = try Events.LogMessage.MessageType.fromString(jsonValueMessageType)
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? Int {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)
                }
                if let jsonValueAppId = jsonMap["appId"] as? String {
                    resultDecodedBuilder.appId = jsonValueAppId
                }
                if let jsonValueSourceType = jsonMap["sourceType"] as? String {
                    resultDecodedBuilder.sourceType = jsonValueSourceType
                }
                if let jsonValueSourceInstance = jsonMap["sourceInstance"] as? String {
                    resultDecodedBuilder.sourceInstance = jsonValueSourceInstance
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Events.LogMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Events.LogMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Events.LogMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Events.LogMessage> {
        var mergedArray = Array<Events.LogMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Events.LogMessage? {
        return try Events.LogMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(data: data, extensionRegistry:Events.LogRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.LogMessage {
        return try Events.LogMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "message": return self.message
        case "messageType": return self.messageType
        case "timestamp": return self.timestamp
        case "appId": return self.appId
        case "sourceType": return self.sourceType
        case "sourceInstance": return self.sourceInstance
        default: return nil
        }
    }
}
extension Events.LogMessage.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Events.LogMessage
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "message": return self.message
            case "messageType": return self.messageType
            case "timestamp": return self.timestamp
            case "appId": return self.appId
            case "sourceType": return self.sourceType
            case "sourceInstance": return self.sourceInstance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.message = newSubscriptValue
            case "messageType":
                guard let newSubscriptValue = newSubscriptValue as? Events.LogMessage.MessageType else {
                    return
                }
                self.messageType = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "appId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.appId = newSubscriptValue
            case "sourceType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sourceType = newSubscriptValue
            case "sourceInstance":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sourceInstance = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
